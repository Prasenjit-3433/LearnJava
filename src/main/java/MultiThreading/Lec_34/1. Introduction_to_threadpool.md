# Thread Pools in Java | ThreadPoolExecutor Framework

## 1. Introduction to Thread Pools

### What is a Thread Pool?

Let's understand thread pools through three key points:

<p align="center">
  <img src="Img/ThreadPool_diagram.png" style="width: 80%;">
</p>

#### 1. Collection of Threads (Workers/Worker Threads)

A **Thread Pool** is essentially a collection of threads that are available to perform submitted tasks.
```
Thread Pool = [Thread 1, Thread 2, Thread 3, ..., Thread N]
```

- You can configure how many threads you want in the pool (5, 10, 20, or any number)
- These threads are also known as **worker threads**
- They are pre-created and ready to work

---

#### 2. Threads Available to Perform Submitted Tasks

**How it works:**
```
Tasks coming in: Task 1, Task 2, Task 3, Task 4, Task 5

Thread Pool: [Thread 1] [Thread 2] [Thread N]

Assignment:
- Task 1 → Thread 1 (Thread 1 becomes BUSY)
- Task 5 → Thread 2 (Thread 2 becomes BUSY)
```

When tasks arrive, worker threads are assigned to perform them. Once assigned, those threads become busy.

---

#### 3. Thread Reusability - Core Advantage

**Key Concept:** Once a thread completes its task, the worker thread returns to the thread pool and waits for a new task to be assigned.

**Example Flow:**
```
1. Task 1 assigned to Thread 1 → Thread 1 BUSY
2. Task 5 assigned to Thread 2 → Thread 2 BUSY
3. Thread 1 completes Task 1 → Thread 1 returns to pool (AVAILABLE)
4. Thread 2 completes Task 5 → Thread 2 returns to pool (AVAILABLE)
5. Thread 1 and Thread 2 now wait for new tasks
```

**The Big Advantage:** We are **reusing threads** instead of creating new ones every time!

---

### Why Thread Reusability Matters?

#### Traditional Approach (Without Thread Pool)

Previously, we used to create threads manually:
```java
Thread thread1 = new Thread();
Thread thread2 = new Thread();
Thread thread3 = new Thread();
```

**Problem:** Thread creation takes time!

**Why does thread creation take time?**

When you create a thread, certain operations must be performed:
1. **Memory allocation for thread stack** - Each thread needs its own stack space
2. **Program counter allocation** - Registers and program counter for each thread
3. **Other thread-specific resources** - Various setup operations

All these operations take time, making thread creation relatively expensive.

---

#### Thread Pool Approach

**With thread pool:**
- Threads are **already created** at initialization
- You just **assign tasks** to existing threads
- No need to create new threads for every request
```
Pre-created pool: [Thread 1] [Thread 2] [Thread 3] [Thread 4] [Thread 5]

Task 1 arrives → Use Thread 1 (no creation needed!)
Task 2 arrives → Use Thread 2 (no creation needed!)
Task 3 arrives → Use Thread 3 (no creation needed!)
```

**Benefit:** We save the **thread creation time** by reusing threads!

**Performance Improvement:** Since threads are pre-created and reused, we avoid the overhead of thread creation with every request, resulting in better performance.

---

### Example: Application Submitting Tasks

Let's see a complete example of how thread pool handles tasks:

#### Setup:
```
Thread Pool: [Thread 1] [Thread 2]  (Only 2 threads)
Queue: [ ]  (Empty queue)

Tasks arriving: Task 1, Task 2, Task 3
```

---

#### Step-by-Step Execution:

**1. Task 1 arrives:**
```
Check: Is any thread available?
Answer: YES

Action: Assign Task 1 to Thread 1
Result: Thread 1 is now BUSY
```

**2. Task 2 arrives:**
```
Check: Is any thread available?
Answer: YES (Thread 2 is free)

Action: Assign Task 2 to Thread 2
Result: Thread 2 is now BUSY

Current State:
- Thread 1: BUSY (processing Task 1)
- Thread 2: BUSY (processing Task 2)
```

**3. Task 3 arrives:**
```
Check: Is any thread available?
Answer: NO (Both Thread 1 and Thread 2 are BUSY)

Action: Put Task 3 in the QUEUE

Current State:
- Thread 1: BUSY (processing Task 1)
- Thread 2: BUSY (processing Task 2)
- Queue: [Task 3]
```

**4. Thread 1 completes Task 1:**
```
Thread 1 completes its work → Returns to the pool

Action: Thread 1 checks the queue
        Finds Task 3 waiting in the queue
        Picks up Task 3 and starts processing

Current State:
- Thread 1: BUSY (processing Task 3)
- Thread 2: Still BUSY (processing Task 2)
- Queue: [ ] (empty)
```

---

### The Role of Queue in Thread Pool

The **queue** plays an **important role** in thread pool management:

**Purpose:**
- Stores tasks when all threads are busy
- Acts as a waiting area for pending tasks
- Tasks wait in queue until a thread becomes available

**Flow:**
```
All threads busy? → Put task in Queue
Thread becomes free? → Check Queue → Pick task from Queue → Execute
```

**Key Point:** Queue allows the thread pool to handle more tasks than the number of available threads, preventing task rejection when threads are temporarily busy.

---

### Summary

| Concept | Description |
|---------|-------------|
| **Thread Pool** | Collection of pre-created worker threads ready to execute tasks |
| **Worker Threads** | Threads in the pool that pick up and execute submitted tasks |
| **Thread Reusability** | Threads return to pool after completing tasks, ready for new assignments |
| **Thread Creation Time** | Saved by reusing existing threads instead of creating new ones |
| **Queue** | Holds tasks when all threads are busy; threads pick from queue when free |

**Main Advantage:** Thread pools eliminate the overhead of creating new threads for every task by maintaining a pool of reusable worker threads, significantly improving application performance.

---